name: Backend CI/CD Pipeline

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - qa
        - prod
      force_deploy:
        description: 'Force deployment even on non-main branch'
        type: boolean
        default: false

  # PR trigger - build only
  pull_request:
    branches: [ main ]
    paths:
    - 'backend/**'
    - 'deployment/backend/**'

  # Push to main - build and deploy to dev
  push:
    branches: [ main ]
    paths:
    - 'backend/**'
    - 'deployment/backend/**'

env:
  APP_NAME: backend
  DOCKERFILE_PATH: ./backend/Dockerfile
  HELM_CHART_PATH: ./deployment/backend

jobs:
  # Stage 1: Build
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      environment: ${{ steps.determine-env.outputs.environment }}
      should-deploy: ${{ steps.determine-env.outputs.should-deploy }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine Environment
      id: determine-env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

    - name: Set Registry and Image Name
      id: registry
      run: |
        case "${{ steps.determine-env.outputs.environment }}" in
          dev)
            echo "registry=mydevacr.azurecr.io" >> $GITHUB_OUTPUT
            echo "image-suffix=-dev" >> $GITHUB_OUTPUT
            echo "tag=dev" >> $GITHUB_OUTPUT
            ;;
          qa)
            echo "registry=myqaacr.azurecr.io" >> $GITHUB_OUTPUT
            echo "image-suffix=-qa" >> $GITHUB_OUTPUT
            echo "tag=qa" >> $GITHUB_OUTPUT
            ;;
          prod)
            echo "registry=myprodacr.azurecr.io" >> $GITHUB_OUTPUT
            echo "image-suffix=-prod" >> $GITHUB_OUTPUT
            echo "tag=prod" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Login to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.registry.outputs.registry }}
        username: ${{ secrets[format('{0}_ACR_USERNAME', steps.determine-env.outputs.environment)] }}
        password: ${{ secrets[format('{0}_ACR_PASSWORD', steps.determine-env.outputs.environment)] }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.registry.outputs.registry }}/${{ env.APP_NAME }}${{ steps.registry.outputs.image-suffix }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=${{ steps.registry.outputs.tag }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ${{ env.DOCKERFILE_PATH }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Output build summary
      run: |
        echo "## ðŸ³ Docker Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** ${{ steps.registry.outputs.registry }}/${{ env.APP_NAME }}${{ steps.registry.outputs.image-suffix }}" >> $GITHUB_STEP_SUMMARY
        echo "**Tag:** ${{ steps.registry.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**Digest:** ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ steps.determine-env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Should Deploy:** ${{ steps.determine-env.outputs.should-deploy }}" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Deploy to Dev (automatic)
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.should-deploy == 'true' && needs.build.outputs.environment == 'dev'
    environment:
      name: dev
      url: https://backend-dev.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Setup Kubernetes CLI
      uses: azure/setup-kubectl@v3

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.DEV_AZURE_CREDENTIALS }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.DEV_RESOURCE_GROUP }} --name ${{ secrets.DEV_AKS_CLUSTER }}

    - name: Deploy with Helm
      run: |
        helm upgrade --install ${{ env.APP_NAME }} ${{ env.HELM_CHART_PATH }} \
          --namespace ${{ env.APP_NAME }}-dev \
          --create-namespace \
          --values ${{ env.HELM_CHART_PATH }}/values.yaml \
          --values ${{ env.HELM_CHART_PATH }}/values.dev.yaml \
          --set image.tag=dev \
          --set image.pullPolicy=Always \
          --wait --timeout=10m

    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ env.APP_NAME }}-dev
        kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-dev

  # Stage 3: Deploy to QA (manual approval required)
  deploy-qa:
    name: Deploy to QA
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.should-deploy == 'true' && needs.build.outputs.environment == 'qa'
    environment:
      name: qa
      url: https://backend-qa.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Setup Kubernetes CLI
      uses: azure/setup-kubectl@v3

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.QA_AZURE_CREDENTIALS }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.QA_RESOURCE_GROUP }} --name ${{ secrets.QA_AKS_CLUSTER }}

    - name: Deploy with Helm
      run: |
        helm upgrade --install ${{ env.APP_NAME }} ${{ env.HELM_CHART_PATH }} \
          --namespace ${{ env.APP_NAME }}-qa \
          --create-namespace \
          --values ${{ env.HELM_CHART_PATH }}/values.yaml \
          --values ${{ env.HELM_CHART_PATH }}/values.qa.yaml \
          --set image.tag=qa \
          --set image.pullPolicy=Always \
          --wait --timeout=10m

    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ env.APP_NAME }}-qa
        kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-qa

    - name: Run smoke tests
      run: |
        # Add smoke tests here
        echo "Running smoke tests for QA environment..."
        # kubectl exec -n ${{ env.APP_NAME }}-qa deployment/${{ env.APP_NAME }} -- curl -f http://localhost:8000/health

  # Stage 4: Deploy to Production (manual approval required)
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.should-deploy == 'true' && needs.build.outputs.environment == 'prod'
    environment:
      name: prod
      url: https://backend.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Setup Kubernetes CLI
      uses: azure/setup-kubectl@v3

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.PROD_AZURE_CREDENTIALS }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.PROD_RESOURCE_GROUP }} --name ${{ secrets.PROD_AKS_CLUSTER }}

    - name: Deploy with Helm
      run: |
        helm upgrade --install ${{ env.APP_NAME }} ${{ env.HELM_CHART_PATH }} \
          --namespace ${{ env.APP_NAME }}-prod \
          --create-namespace \
          --values ${{ env.HELM_CHART_PATH }}/values.yaml \
          --values ${{ env.HELM_CHART_PATH }}/values.prod.yaml \
          --set image.tag=prod \
          --set image.pullPolicy=Always \
          --wait --timeout=15m

    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ env.APP_NAME }}-prod
        kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-prod

    - name: Run production health checks
      run: |
        echo "Running production health checks..."
        # Add comprehensive health checks here
        # kubectl exec -n ${{ env.APP_NAME }}-prod deployment/${{ env.APP_NAME }} -- curl -f http://localhost:8000/health

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'